// Generates *_decl.inc and *_impl.inc files from keys.toml per target class
//
// Usage: stub_generator <keys.toml> <output_dir>
// Example: stub_generator res/config/keys.toml src/keys/

#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <string>

#include <toml++/toml.hpp>

namespace fs = std::filesystem;

// Mapping from TOML section name to target class name
const std::map<std::string, std::string> sectionToClass = {
    {"Panel", "FilePanel"},
    {"Tabs", "MainWindow"},
    {"MainFrame", "MainWindow"},
    {"CommandLine", "MainWindow"},
    {"SearchEdit", "SearchEdit"},
    {"EditorTabs", "EditorFrame"},
    {"EditorFrame", "EditorFrame"},
    {"Editor", "Editor"},
    {"Viewer", "Viewer"},
};

bool isValidHandler(const std::string& handler)
{
    // Skip "none" and "default"
    if (handler == "none" || handler == "default")
        return false;

    return !handler.empty();
}

std::map<std::string, std::set<std::string>> extractHandlersByClass(const toml::table& tbl)
{
    std::map<std::string, std::set<std::string>> handlersByClass;

    for (auto&& [sectionName, node] : tbl) {
        if (!node.is_table())
            continue;

        // Find target class for this section
        auto it = sectionToClass.find(std::string(sectionName.str()));
        if (it == sectionToClass.end()) {
            std::cerr << "Warning: Unknown section [" << sectionName << "], skipping\n";
            continue;
        }
        const std::string& targetClass = it->second;

        auto* widgetTable = node.as_table();
        if (!widgetTable)
            continue;

        auto keysNode = widgetTable->get("keys");
        if (!keysNode || !keysNode->is_array())
            continue;

        auto* arr = keysNode->as_array();
        if (!arr)
            continue;

        for (auto&& item : *arr) {
            if (!item.is_table())
                continue;

            auto* keyTable = item.as_table();
            if (!keyTable)
                continue;

            auto handlerNode = keyTable->get("handler");
            if (!handlerNode)
                continue;

            auto handlerOpt = handlerNode->value<std::string>();
            if (!handlerOpt)
                continue;

            const std::string& handler = *handlerOpt;

            if (isValidHandler(handler)) {
                handlersByClass[targetClass].insert(handler);
            }
        }
    }

    return handlersByClass;
}

void writeDeclarations(const std::string& className, const std::set<std::string>& handlers,
    const fs::path& outputPath)
{
    std::ofstream out(outputPath);
    if (!out) {
        throw std::runtime_error("Cannot open for writing: " + outputPath.string());
    }

    out << "// Auto-generated by stub_generator - do not edit manually\n";
    out << "// Handler declarations for " << className << "\n\n";

    for (const auto& name : handlers) {
        out << "    Q_INVOKABLE bool " << name << "(QObject *obj, QKeyEvent *keyEvent);\n";
    }

    out.close();
    std::cout << "Written: " << outputPath << " (" << handlers.size() << " handlers)\n";
}

void writeImplementations(const std::string& className, const std::set<std::string>& handlers,
    const fs::path& outputPath)
{
    std::ofstream out(outputPath);
    if (!out) {
        throw std::runtime_error("Cannot open for writing: " + outputPath.string());
    }

    out << "// Auto-generated by stub_generator - do not edit manually\n";
    out << "// Handler stub implementations for " << className << "\n\n";

    for (const auto& name : handlers) {
        out << "bool " << className << "::" << name << "(QObject *obj, QKeyEvent *keyEvent) {\n";
        out << "    Q_UNUSED(obj);\n";
        out << "    Q_UNUSED(keyEvent);\n";
        out << "    qDebug() << \"handler: " << name << "\";\n";
        out << "    return false;\n";
        out << "}\n\n";
    }

    out.close();
    std::cout << "Written: " << outputPath << " (" << handlers.size() << " handlers)\n";
}

int main(int argc, char* argv[])
{
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <keys.toml> <output_dir>\n";
        std::cerr << "Example: " << argv[0] << " res/config/keys.toml src/keys/\n";
        return 1;
    }

    fs::path tomlPath = argv[1];
    tomlPath = fs::weakly_canonical(tomlPath);
    fs::path outputDir = argv[2];
    outputDir = fs::weakly_canonical(outputDir);

    if (!fs::exists(tomlPath)) {
        std::cerr << "Error: TOML file not found: " << tomlPath << "\n";
        return 1;
    }

    if (!fs::is_directory(outputDir)) {
        std::cerr << "Error: Output directory does not exist: " << outputDir << "\n";
        return 1;
    }

    try {
        toml::table tbl = toml::parse_file(tomlPath.string());

        auto handlersByClass = extractHandlersByClass(tbl);

        if (handlersByClass.empty()) {
            std::cerr << "Warning: No handlers found in " << tomlPath << "\n";
            return 1;
        }

        int totalHandlers = 0;
        for (const auto& [className, handlers] : handlersByClass) {
            if (handlers.empty())
                continue;

            std::cout << "Class " << className << ": " << handlers.size() << " handlers\n";
            totalHandlers += handlers.size();

            fs::path declPath = outputDir / (className + "_decl.inc");
            fs::path implPath = outputDir / (className + "_impl.inc");

            writeDeclarations(className, handlers, declPath);
            writeImplementations(className, handlers, implPath);
        }

        std::cout << "Done. Total: " << totalHandlers << " handlers across "
                  << handlersByClass.size() << " classes.\n";
        return 0;

    } catch (const toml::parse_error& err) {
        std::cerr << "TOML parse error: " << err.description() << "\n";
        return 1;
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << "\n";
        return 1;
    }
}