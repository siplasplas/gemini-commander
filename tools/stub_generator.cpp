// Generates handlers_decl.inc and handlers_impl.inc from keys.toml
//
// Usage: placeholder_generator <keys.toml> <output_dir>
// Example: placeholder_generator res/config/keys.toml src/

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <set>
#include <string>

#include <toml++/toml.hpp>

namespace fs = std::filesystem;

std::set<std::string> extractHandlers(const toml::table& tbl)
{
    std::set<std::string> handlers;

    for (auto&& [widgetName, node] : tbl) {
        if (!node.is_table())
            continue;

        auto* widgetTable = node.as_table();
        if (!widgetTable)
            continue;

        auto keysNode = widgetTable->get("keys");
        if (!keysNode || !keysNode->is_array())
            continue;

        auto* arr = keysNode->as_array();
        if (!arr)
            continue;

        for (auto&& item : *arr) {
            if (!item.is_table())
                continue;

            auto* keyTable = item.as_table();
            if (!keyTable)
                continue;

            auto handlerNode = keyTable->get("handler");
            if (!handlerNode)
                continue;

            auto handlerOpt = handlerNode->value<std::string>();
            if (!handlerOpt)
                continue;

            const std::string& handler = *handlerOpt;

            // Skip "none" and pseudo-handlers like LETTERS, DIGITS
            if (handler == "none")
                continue;
            if (handler == "LETTERS" || handler == "DIGITS")
                continue;
            if (std::isupper(handler[0]) && handler.find('_') == std::string::npos) {
                // Skip all-caps identifiers that aren't real handlers
                bool allUpper = std::all_of(handler.begin(), handler.end(),
                    [](char c) { return std::isupper(c) || std::isdigit(c); });
                if (allUpper)
                    continue;
            }

            handlers.insert(handler);
        }
    }

    return handlers;
}

void writeDeclarations(const std::set<std::string>& handlers, const fs::path& outputPath)
{
    std::ofstream out(outputPath);
    if (!out) {
        throw std::runtime_error("Cannot open for writing: " + outputPath.string());
    }

    out << "// Auto-generated by placeholder_generator - do not edit manually\n";
    out << "// Handler declarations for MainWindow\n\n";

    for (const auto& name : handlers) {
        out << "    Q_INVOKABLE bool " << name << "(QKeyEvent *keyEvent);\n";
    }

    out.close();
    std::cout << "Written: " << outputPath << " (" << handlers.size() << " handlers)\n";
}

void writeImplementations(const std::set<std::string>& handlers, const fs::path& outputPath)
{
    std::ofstream out(outputPath);
    if (!out) {
        throw std::runtime_error("Cannot open for writing: " + outputPath.string());
    }

    out << "// Auto-generated by placeholder_generator - do not edit manually\n";
    out << "// Handler stub implementations for MainWindow\n\n";

    for (const auto& name : handlers) {
        out << "bool MainWindow::" << name << "(QKeyEvent *keyEvent) {\n";
        out << "    Q_UNUSED(keyEvent);\n";
        out << "    qDebug() << \"handler: " << name << "\";\n";
        out << "    return false;\n";
        out << "}\n\n";
    }

    out.close();
    std::cout << "Written: " << outputPath << " (" << handlers.size() << " handlers)\n";
}

int main(int argc, char* argv[])
{
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <keys.toml> <output_dir>\n";
        std::cerr << "Example: " << argv[0] << " res/config/keys.toml src/\n";
        return 1;
    }

    fs::path tomlPath = argv[1];
    tomlPath = fs::weakly_canonical(tomlPath);
    fs::path outputDir = argv[2];
    outputDir = fs::weakly_canonical(outputDir);

    if (!fs::exists(tomlPath)) {
        std::cerr << "Error: TOML file not found: " << tomlPath << "\n";
        return 1;
    }

    if (!fs::is_directory(outputDir)) {
        std::cerr << "Error: Output directory does not exist: " << outputDir << "\n";
        return 1;
    }

    try {
        toml::table tbl = toml::parse_file(tomlPath.string());

        auto handlers = extractHandlers(tbl);

        if (handlers.empty()) {
            std::cerr << "Warning: No handlers found in " << tomlPath << "\n";
            return 1;
        }

        std::cout << "Found " << handlers.size() << " unique handlers\n";

        writeDeclarations(handlers, outputDir / "handlers_decl.inc");
        writeImplementations(handlers, outputDir / "handlers_impl.inc");

        std::cout << "Done.\n";
        return 0;

    } catch (const toml::parse_error& err) {
        std::cerr << "TOML parse error: " << err.description() << "\n";
        return 1;
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << "\n";
        return 1;
    }
}